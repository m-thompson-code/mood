import { ComponentFixture, TestBed } from '@angular/core/testing';
import { FormGroup, ReactiveFormsModule } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { AngularFirestoreModule } from '@angular/fire/firestore';
import { AngularFireAuth, AngularFireAuthModule } from '@angular/fire/auth';

import { LoginComponent } from './login.component';
import { RouterTestingModule } from '@angular/router/testing';
import { Component } from '@angular/core';
import { Router } from '@angular/router';


@Component({
    selector: 'mat-form-field',
    template: '',
})
class MockFormField {}

@Component({
    selector: 'input[matInput]',
    template: '',
})
class MockInput {}

@Component({
    selector: 'button[mat-raised-button]',
    template: '',
})
class MockButton {}

@Component({
    selector: 'mat-label',
    template: '',
})
class MockLabel {}

@Component({
    selector: 'mat-error',
    template: '',
})
class MockError {}

const mockMatSnackBar = {
    open: () => {},
};

const mockAngularFireAuth = {
    signInWithEmailAndPassword: () => Promise.resolve(),
};

describe('LoginComponent', () => {
    let component: LoginComponent;
    let fixture: ComponentFixture<LoginComponent>;
    let matSnackBar: MatSnackBar;
    let authService: AngularFireAuth;
    let router: Router;

    beforeEach(async () => {
        await TestBed.configureTestingModule({
            declarations: [
                LoginComponent,
                MockFormField,
                MockInput,
                MockButton,
                MockLabel,
                MockError,
            ],
            providers: [
                { provide: MatSnackBar, useValue: mockMatSnackBar },
                { provide: AngularFireAuth, useValue: mockAngularFireAuth },
            ],
            imports: [
                ReactiveFormsModule,
                RouterTestingModule,
            ]
        }).compileComponents();
    });

    beforeEach(() => {
        fixture = TestBed.createComponent(LoginComponent);
        component = fixture.componentInstance;
        fixture.detectChanges();

        matSnackBar = TestBed.inject(MatSnackBar);
        authService = TestBed.inject(AngularFireAuth);
        router = TestBed.inject(Router);
    });

    it('should create', () => {
        expect(component).toBeTruthy();
    });

    describe('formIsValid()', () => {
        it('should validate and update FormGroup state', () => {
            const spy = jest.spyOn(component.form, 'updateValueAndValidity');
            component.formIsValid();
            expect(spy).toBeCalledTimes(1);
        });

        it('should return if FormGroup is valid or not', () => {
            component.form.setValue({
                email: 'moo@moo.moo',
                password: 'some password',
            });

            const result = component.formIsValid();
            expect(result).toBe(true);
        });
    });

    describe('getEmailAndPassword()', () => {
        it('should get email and password from FormGroup', () => {
            component.form.setValue({
                email: 'moo@moo.moo',
                password: 'some password',
            });

            const result = component.getEmailAndPassword();
    
            expect(result).toStrictEqual({
                email: 'moo@moo.moo',
                password: 'some password',
            });
        });

        it('should return empty strings if values are not set for email and password', () => {
            component.form.setValue({
                email: null,
                password: null,
            });

            const result = component.getEmailAndPassword();
    
            expect(result).toStrictEqual({
                email: '',
                password: '',
            });
        });
    });

    describe('login()', () => {
        it('should exit early if form is not valid', () => {
            jest.spyOn(component, 'formIsValid').mockReturnValue(false);

            const spy = jest.spyOn(component, 'toast');

            component.login();

            expect(spy).toBeCalledWith('Nope, your email and secret thing is bad');
        });

        describe('when form is valid', () => {
            beforeEach(() => {
                jest.spyOn(component, 'formIsValid').mockReturnValue(true);

                jest.spyOn(component, 'getEmailAndPassword').mockReturnValue({
                    email: 'some cool email',
                    password: 'some cool password',
                });
            });

            it('should pass email and password to Service', () => {
                const spy = jest.spyOn(authService, 'signInWithEmailAndPassword');
    
                component.login();
    
                expect(spy).toBeCalledWith('some cool email', 'some cool password');
            });
    
            it('should navigate on success', (done) => {
                expect.assertions(1);

                jest.spyOn(authService, 'signInWithEmailAndPassword').mockReturnValue(Promise.resolve({} as ReturnType<AngularFireAuth['signInWithEmailAndPassword']>));
    
                const spy = jest.spyOn(router, 'navigate');

                component.login().then(() => {
                    expect(spy).toBeCalledWith(['']);
                    done();
                });
            });
    
            it('should toast error message on failure', (done) => {
                expect.assertions(1);

                jest.spyOn(authService, 'signInWithEmailAndPassword').mockReturnValue(Promise.reject({message: 'some error message' }));
    
                const spy = jest.spyOn(component, 'toast');

                component.login().then(() => {
                    expect(spy).toBeCalledWith('some error message');
                    done();
                });
            });

            it('should toast default error message on failure if error does not have message property', (done) => {
                expect.assertions(1);

                jest.spyOn(authService, 'signInWithEmailAndPassword').mockReturnValue(Promise.reject({message: null }));
    
                const spy = jest.spyOn(component, 'toast');

                component.login().then(() => {
                    expect(spy).toBeCalledWith('Unknown error. Sry not sry');
                    done();
                });
            });
        });
    });

    describe('toast()', () => {
        it('should show message for 3 seconds', () => {
            const spy = jest.spyOn(matSnackBar, 'open');
            component.toast('moocow');
            expect(spy).toBeCalledWith('moocow', undefined, {
                duration: 3000,
            });
        });
    });
});
